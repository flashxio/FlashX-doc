<!DOCTYPE html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="The programming tutorial of FlashGraph">
<meta name="keywords" content="tutorial,  tutorial">
<title>The programming tutorial of FlashGraph | Documentation of FlashX</title>
<link rel="stylesheet" href="css/syntax.css">


<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
<!--<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">-->
<link rel="stylesheet" href="css/modern-business.css">
<link rel="stylesheet" href="css/lavish-bootstrap.css">
<link rel="stylesheet" href="css/customstyles.css">
<link rel="stylesheet" href="css/theme-blue.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="js/jquery.navgoco.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/2.0.0/anchor.min.js"></script>
<script src="js/toc.js"></script>
<script src="js/customscripts.js"></script>

<link rel="shortcut icon" href="images/favicon.ico">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link rel="alternate" type="application/rss+xml" title="" href="http://localhost:4005feed.xml">

    <script>
        $(document).ready(function() {
            // Initialize navgoco with default options
            $("#mysidebar").navgoco({
                caretHtml: '',
                accordion: true,
                openClass: 'active', // open
                save: false, // leave false or nav highlighting doesn't work right
                cookie: {
                    name: 'navgoco',
                    expires: false,
                    path: '/'
                },
                slide: {
                    duration: 400,
                    easing: 'swing'
                }
            });

            $("#collapseAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', false);
            });

            $("#expandAll").click(function(e) {
                e.preventDefault();
                $("#mysidebar").navgoco('toggle', true);
            });

        });

    </script>
    <script>
        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        })
    </script>
    

</head>
<body>
<!-- Navigation -->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="fa fa-home fa-lg navbar-brand" href="index.html">&nbsp;<span class="projectTitle"> Documentation of FlashX</span></a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- entries without drop-downs appear here -->
                
                
                
                <li><a href="https://github.com/zheng-da/FlashX" target="_blank">Source code</a></li>
                
                
                
                <!-- entries with drop-downs appear here -->
                <!-- conditional logic to control which topnav appears for the audience defined in the configuration file.-->
                
                
			<li><a class="email" title="Submit feedback" href="#" onclick="javascript:window.location='mailto:zhengda1936@gmail.com?subject=Documentation of FlashX f eedback&body=I have some feedback about the The programming tutorial of FlashGraph page: ' + window.location.href;"><i class="fa fa-envelope-o"></i> Feedback</a><li>

		
                <!--comment out this block if you want to hide search-->
                <li>
                    <!--start search-->
                    <div id="search-demo-container">
                        <input type="text" id="search-input" placeholder="search...">
                        <ul id="results-container"></ul>
                    </div>
                    <script src="js/jekyll-search.js" type="text/javascript"></script>
                    <script type="text/javascript">
                            SimpleJekyllSearch.init({
                                searchInput: document.getElementById('search-input'),
                                resultsContainer: document.getElementById('results-container'),
                                dataSource: 'search.json',
                                searchResultTemplate: '<li><a href="{url}" title="The programming tutorial of FlashGraph">{title}</a></li>',
                    noResultsText: 'No results found.',
                            limit: 10,
                            fuzzy: true,
                    })
                    </script>
                    <!--end search-->
                </li>
            </ul>
        </div>
        </div>
        <!-- /.container -->
</nav>

<!-- Page Content -->
<div class="container">
    <div class="col-lg-12">&nbsp;</div>
    <!-- Content Row -->
    <div class="row">
        <!-- Sidebar Column -->
        <div class="col-md-3">

          












<ul id="mysidebar" class="nav">
    <li class="sidebarTitle">Documentation of FlashX 6.0</li>
    
    
    
        
    
    <li>
        <a href="#">Overview</a>
        <ul>
            
            
            
            <li><a href="FlashX-Quick-Start-Guide.html">Get started</a></li>
            
            
            
            
            
            
            <li><a href="mydoc_about.html">About the theme author</a></li>
            
            
            
            
            
            
            <li><a href="mydoc_support.html">Support</a></li>
            
            
            
            
        </ul>
        
        
    
    <li>
        <a href="#">User Guide</a>
        <ul>
            
            
            
            <li><a href="FlashGraph-user-guide.html">FlashGraph</a></li>
            
            
            
            
            
            
            <li><a href="FlashMatrix-user-guide.html">FlashMatrix</a></li>
            
            
            
            
        </ul>
        
        
    
    <li>
        <a href="#">Tutorials</a>
        <ul>
            
            
            
            <li><a href="FlashMatrix-programming-tutorial.html">FlashMatrix</a></li>
            
            
            
            
        </ul>
        
        
    
    <li>
        <a href="#">Contributing</a>
        <ul>
            
            
            
            <li><a href="mydoc_pages.html">Pages</a></li>
            
            
            
            
        </ul>
        
        
    
    <li>
        <a href="#">API</a>
        <ul>
            
            
            
            <li><a href="http://flashx.io/docs/html/" target="_blank">C++</a></li>
            
            
            
            
            
            
            <li><a href="http://flashx.io/docs/FlashR/" target="_blank">R</a></li>
            
            
            
            
        </ul>
        
        
    
    <li>
        <a href="#">Troubleshooting</a>
        <ul>
            
            
            
            <li><a href="mydoc_troubleshooting.html">Troubleshooting</a></li>
            
            
            
            
        </ul>
        
        
        
        <!-- if you aren't using the accordion, uncomment this block:
           <p class="external">
               <a href="#" id="collapseAll">Collapse All</a> | <a href="#" id="expandAll">Expand All</a>
           </p>
           -->
    </li>
</ul>
</div>

<!-- this highlights the active parent class in the navgoco sidebar. this is critical so that the parent expands when you're viewing a page. This must appear below the sidebar code above. Otherwise, if placed inside customscripts.js, the script runs before the sidebar code runs and the class never gets inserted.-->
<script>$("li.active").parents('li').toggleClass("active");</script>

    <!-- Content Column -->
    <div class="col-md-9">
        <div class="post-header">
   <h1 class="post-title-main">The programming tutorial of FlashGraph</h1>
</div>



<div class="post-content">

   
    <div class="summary">The programming tutorial of FlashGraph</div>
   

    
    
<!-- this handles the automatic toc. use ## for subheads to auto-generate the on-page minitoc. if you use html tags, you must supply an ID for the heading element in order for it to appear in the minitoc. -->
<script>
$( document ).ready(function() {
  // Handler for .ready() called.

$('#toc').toc({ minimumHeaders: 0, listType: 'ul', showSpeed: 0, headers: 'h2,h3,h4' });

/* this offset helps account for the space taken up by the floating toolbar. */
$('#toc').on('click', 'a', function() {
  var target = $(this.getAttribute('href'))
    , scroll_target = target.offset().top

  $(window).scrollTop(scroll_target - 10);
  return false
})
  
});
</script>

<div id="toc"></div>

    

    

    

    <a target="_blank" href="https://github.com/tomjohnson1492/documentation-theme-jekyll/blob/gh-pages/pages//_pages/mydoc/FlashGraph-programming-tutorial.html.md" class="btn btn-default githubEditButton" role="button"><i class="fa fa-github fa-lg"></i> Edit me</a>
    

    

  <p>FlashGraph provides a flexible vertex-centric programming interface. In this programming model, each vertex performs user-defined tasks independently and interacts with other vertices as defined by program logic. A vertex affects the state of others by sending messages to them as well as activating them. Notably, FlashGraph allows a vertex to send messages to any vertex in the graph. A vertex can also read the vertex information of any vertex from SSDs as well as the state of any vertex in memory.</p>

<p>A graph algorithm usually progresses in iterations. In each iteration, the graph engine executes a user-defined task on each activated vertex. An iteration ends when there are no more active vertices in the iteration and no vertices have pending requests in the graph engine. An algorithm ends when there aren’t active vertices in the next iteration.</p>

<h1 id="vertex-program">Vertex program</h1>

<p>The most commonly way of implementing a graph algorithm in FlashGraph is to define computation vertices by inheriting the <code class="highlighter-rouge">compute_vertex</code> class . Users define vertex state and implement three <code class="highlighter-rouge">run</code> methods in the computation vertices, as shown below. FlashGraph executes the <code class="highlighter-rouge">run</code> method exactly once for each active vertex in an iteration; the order of execution of this method on vertices is subject to scheduling by FlashGraph. The execution of the <code class="highlighter-rouge">run_on_vertex</code> and <code class="highlighter-rouge">run_on_message</code> methods is event-driven. FlashGraph executes <code class="highlighter-rouge">run_on_vertex</code> when the edge list of a vertex requested by the current vertex is ready in the page cache. FlashGraph executes <code class="highlighter-rouge">run_on_message</code> if the vertex receives messages from other vertices. The <code class="highlighter-rouge">run_on_message</code> method may be executed even if a vertex is inactive in an iteration. All examples assume <code class="highlighter-rouge">using namespace fg;</code> is declared.</p>

<pre><code class="language-{.cpp}">class compute_vertex
{
  // run only on the vertex state.
  void run(vertex_program &amp;prog);

  // run on the edge list of a vertex
  void run_on_vertex(vertex_program &amp;prog, page_vertex &amp;vertex);

  // process a message.
  void run_on_message(vertex_program &amp;prog, vertex_message &amp;msg);
};
</code></pre>

<p>Given the programming interface, breadth-first search can be simply expressed as the code below. If a vertex has not been visited, it issues a request to read its neighbor list in <code class="highlighter-rouge">run</code> and activates its neighbors in <code class="highlighter-rouge">run_on_vertex</code>. In this example, vertices do not need to send messages to one another so we do not need to implement <code class="highlighter-rouge">run_on_message</code>.</p>

<pre><code class="language-{.cpp}">class bfs_vertex: public vertex
{
  bool has_visited;
  bfs_vertex() {
    has_visited = false;
  }

  void run(vertex_program &amp;prog) {
    if (!has_visited) {
      vertex_id_t id = prog.get_vertex_id(*this);

      // Request vertex neighbor list from SAFS
      request_vertices(&amp;id, 1);
      set_visited = true;
    }
  }

  void run_on_vertex(vertex_program &amp;prog, page_vertex &amp;vertex) {
    vertex_id_t dest_buf[];
    vertex.read_edges(dest_buf);
    prog.activate_vertices(dest_buf, num_dests);
  }

  void run_on_message(vertex_program &amp;prog, vertex_message &amp;msg) {
  }
};
</code></pre>

<h1 id="initialize-vertex-state">Initialize vertex state</h1>

<p>There are two ways of initializing vertex state. Programmers can initialize vertex state in the constructor of the user-defined computation vertex. In the example of BFS, programmers only need to initialize <code class="highlighter-rouge">has_visited</code> in the constructor of bfs_vertex. For simple graph algorithms, this is usually enough.</p>

<p>In a more complex case, a graph algorithm may require to execute the vertex program multiple times or execute multiple vertex programs. Therefore, it needs to set some vertices to a certain state or reset all vertices. FlashGraph provides another mechanism to initialize vertex state. Programmers need to implement the <code class="highlighter-rouge">vertex_initiator</code> interface, shown as below. Users can pass a customized vertex initializer to the graph engine by invoking its <code class="highlighter-rouge">init_all_vertices()</code> or its start function. An example of using a customized vertex initializer can be found in <a href="https://github.com/icoming/FlashGraph/blob/graph-release/flash-graph/sssp/sssp.cpp">single source shortest path</a>.</p>

<pre><code class="language-{.cpp}">class vertex_initiator
{
public:
    typedef std::shared_ptr&lt;vertex_initiator&gt; ptr;
    virtual void init(compute_vertex &amp;) = 0;
};
</code></pre>

<h1 id="interaction-with-other-vertices">Interaction with other vertices</h1>

<p>There are four ways for a vertex to interact with other vertices: a vertex can send messages to other vertices; a vertex can read in-memory vertex state of other vertices directly; a vertex can read the adjacency list of other vertices from SSDs.</p>

<h2 id="message-passing">message passing</h2>

<p>FlashGraph provides two methods for message passing: <code class="highlighter-rouge">vertex_program::send_msg()</code> and <code class="highlighter-rouge">vertex_program::multicast_msg()</code>. The former method is point-to-point communication between two vertices and the second method allows a vertex to send a message to multiple vertices. In most of the cases, multicast is used because multicast has much smaller overhead and most graph algorithms require a vertex to send the same message to all of its neighbors. A vertex gets notified of the messages sent from other vertices through <code class="highlighter-rouge">run_on_message()</code>.</p>

<p>All messages need to be inherited from the <code class="highlighter-rouge">vertex_message</code> class. Its constructor takes two arguments: the size of the user-defined message and the <code class="highlighter-rouge">activate</code> flag. When the <code class="highlighter-rouge">activate</code> flag is set, the recipient vertices will be activated.</p>

<p>To reduce memory consumption, FlashGraph delivers messages to vertices whenever it receives messages. Therefore, there is no guarantee of the execution order of the three run methods. It is programmers’ responsibility of maintaining the correctness of vertex state. By delivering messages to vertices immediately, we enable asynchronous execution of graph algorithms. That is, an update to vertex state can be immediately exposed to other vertices. It has advantage for some graph algorithms because asynchronous execution can accelerate some graph algorithms. This is very different from Pregel, which only delivers messages to vertices at the end of an iteration.</p>

<h2 id="vertex-activation">Vertex activation</h2>

<p>A vertex can activate other vertices to run in the next iteration. There are two ways of activating other vertices: with the dedicated methods <code class="highlighter-rouge">vertex_program::activate_vertex</code> and <code class="highlighter-rouge">vertex_program::activate_vertices</code>; with the activate flag in messages sent to other vertices.</p>

<h2 id="directed-memory-read">Directed memory read</h2>

<p>We can get a reference to a vertex of a specified ID with <code class="highlighter-rouge">graph_engine::get_vertex()</code>. This interface only works in a shared-memory machine and may cause significant random memory access. Therefore, this interface is not favored and should be used with caution.</p>

<h2 id="access-adjacency-list-from-ssds">Access adjacency list from SSDs</h2>
<p>It takes two steps to read adjacency lists from SSDs: a vertex issues read requests; the user-defined computation vertex gets notified through its <code class="highlighter-rouge">run_on_vertex()</code>. A vertex can read entire adjacency lists with <code class="highlighter-rouge">compute_vertex::request_vertices()</code>. A directed vertex can read partial adjacency lists with <code class="highlighter-rouge">compute_directed_vertex::request_partial_vertices()</code>. In a partial request, a directed vertex can request an in-edge list or an out-edge list or both.</p>

<h2 id="data-iterators">Data iterators</h2>
<p>FlashGraph defines very useful iterators for neighbor lists and edge attributes (for graphs that contain them).
FlashGraph implements both sequential (Java-style) iterators and traditional STL-style iterators. Java-style iterators will improve performance in sequential access tasks and can be parameterized with a <code class="highlighter-rouge">start</code> and <code class="highlighter-rouge">end</code> positions for partial edge list numeration. For both examples assume the vertex has requested it’s edge list in the <code class="highlighter-rouge">run(vertex_program &amp;prog)</code> method.</p>

<h3 id="java-style-iterators">Java-style iterators</h3>
<p>The code below shows how the Java-style iterators can be used to iterate an edge list and access a data item in an attributed graph.</p>

<pre><code class="language-{.cpp}">typedef safs::page_byte_array::const_iterator&lt;edge_data_type&gt; data_iterator;
typedef safs::page_byte_array::seq_const_iterator&lt;edge_count&gt; data_seq_iterator;

void nmf_vertex::run(vertex_program &amp;prog, const page_vertex &amp;vertex) {
    // Iterator for neighbor IDs
    edge_seq_iterator neigh_it = vertex.get_neigh_seq_it(IN_EDGE);
    // Iterator for egde count (weight) attribute
    data_seq_iterator count_it =
        ((const page_directed_vertex&amp;)vertex).get_data_seq_it&lt;edge_count&gt;(IN_EDGE);

    while (neigh_it.has_next()) {
        vertex_id_t nid = neigh_it.next();
        edge_count e = count_it.next();

        // Make use of `nid` and `e`
        std::cout &lt;&lt; "Neighbor = " &lt;&lt; nid &lt;&lt; " Edge count = "
                      &lt;&lt; e.get_count() &lt;&lt; std::endl;
    }
}
</code></pre>

<h3 id="stl-style-iterators">STL-style iterators</h3>
<p>The code below shows how the STL-style iterators can be used to iterate an edge list and access a data item in an attributed graph.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
void nmf_vertex::run(vertex_program &amp;prog, const page_vertex &amp;vertex) {
    // Iterator for neighbor IDs
    edge_iterator neigh_it = vertex.get_neigh_begin(edge_type::OUT_EDGE);
    edge_iterator neigh_end = vertex.get_neigh_end(edge_type::OUT_EDGE);</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// Iterator for edge count (weight) attribute
data_iterator count_it = 
      ((const page_directed_vertex&amp;)vertex).get_data_begin(OUT_EDGE);
data_iterator count_end = 
         ((const page_directed_vertex&amp;)vertex).get_data_end(OUT_EDGE);

for (; neigh_it != neigh_end; ++neigh_it) {
    vertex_id_t nid = *it;
    ++count_it;
    edge_count e = *count_it;

    // Make use of `nid` and `e`
    std::cout &lt;&lt; "Neighbor = " &lt;&lt; nid &lt;&lt; " Edge count = "
                          &lt;&lt; e.get_count() &lt;&lt; std::endl;
} } ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
</div>

<h1 id="execute-vertex-program">Execute vertex program</h1>

<p>The code below executes the BFS program shown above. We create a <code class="highlighter-rouge">graph_index</code> object that contains the user-defined vertex state for all vertices and create a <code class="highlighter-rouge">graph_engine</code> object that executes the user code for the graph algorithm. In the case of BFS, the algorithm starts on a single vertex. When a graph engine starts, the user code runs in the worker threads inside the graph engine. We can invoke <code class="highlighter-rouge">wait4complete</code> to wait the graph algorithm to complete.</p>

<pre><code class="language-{.cpp}">graph_index::ptr index = NUMA_graph_index&lt;bfs_vertex&gt;::create(index_file);
graph_engine::ptr graph = graph_engine::create(graph_file, index, configs);

graph-&gt;start(&amp;start_vertex, 1);
graph-&gt;wait4complete();
</code></pre>

<h1 id="synchronous-execution">Synchronous execution</h1>

<p>By default, FlashGraph executes user-defined vertex computation asynchronously. That is, the update to the vertex state is immediately exposed to all other vertices in the same iteration. The asynchronous execution can accelerate the convergence of many graph algorithms. However, it is not deterministic and some graph algorithms need to be executed synchronously.</p>

<p>FlashGraph also allows synchronous execution. FIXME</p>


    <div class="tags">
        
        <b>Tags: </b>
        
        
        
        
        
    </div>

    

</div>

<hr class="shaded"/>

<footer>
            <div class="row">
                <div class="col-lg-12 footer">
               &copy;2016 FlashX. All rights reserved. <br />
<span>Page last updated:</span> Nov 3, 2016<br/> Site last generated: Nov 3, 2016 <br />
<p><img src="images/company_logo.png" alt="Company logo"/></p>
                </div>
            </div>
</footer>


    </div>
    <!-- /.row -->
</div>
<!-- /.container -->
    </div>

</body>

</html>